{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#django-mail-auth","title":"Django Mail Auth","text":"<p>Django Mail Auth is a lightweight authentication backend for Django, that does not require users to remember passwords.</p> <p>Django Mail Auth features:</p> <ul> <li>custom user model support</li> <li>drop in Django admin support</li> <li>drop in Django User replacement</li> <li>drop in Wagtail login replacement</li> <li>extendable SMS support</li> </ul> <p></p> <p>This project was inspired by:</p> <ul> <li>Is it time for password-less login?   by Ben Brown</li> <li>LOGIN WITHOUT PASSWORD MOST SECURE | WAIT.. WHAT?   by Joris Snoek</li> <li>django-nopassword by   Rolf Erik Lekang</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Run this command to install <code>django-mail-auth</code>:</p> <pre><code>python3 -m pip install django-mail-auth[wagtail]\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<p>First add <code>mailauth</code> to you installed apps:</p> <pre><code>INSTALLED_APPS = [\n    # Django's builtin apps\u2026\n    \"mailauth\",\n    \"mailauth.contrib.admin\",  # optional\n    \"mailauth.contrib.user\",  # optional\n    # optional, must be included before \"wagtail.admin\"\n    \"mailauth.contrib.wagtail\",\n    # other apps\u2026\n]\n</code></pre> <p><code>mailauth.contrib.admin</code> is optional and will replace the admin's login with token based authentication too.</p> <p><code>mailauth.contrib.user</code> is optional and provides a new Django User model. The new User model needs to be enabled via the <code>AUTH_USER_MODEL</code> setting:</p> <pre><code># This setting should be either \"EmailUser\" or\n# any custom subclass of \"AbstractEmailUser\"\nAUTH_USER_MODEL = \"mailauth_user.EmailUser\"\n\n# optional, Wagtail only\nWAGTAILUSERS_PASSWORD_ENABLED = False\n</code></pre> <p>Next you will need to add the new authentication backend:</p> <pre><code>AUTHENTICATION_BACKENDS = (\n    # default, but now optional\n    # This should be removed if you use mailauth.contrib.user or any other\n    # custom user model that does not have a username/password\n    \"django.contrib.auth.backends.ModelBackend\",\n    # The new access token based authentication backend\n    \"mailauth.backends.MailAuthBackend\",\n)\n</code></pre> <p>Django's <code>ModelBackend</code> is only needed, if you still want to support password based authentication. If you don't, simply remove it from the list.</p> <p>Last but not least, go to your URL root configuration <code>urls.py</code> and add the following:</p> <pre><code>from django.urls import path\n\n\nurlpatterns = [\n    path(\"accounts/\", include(\"mailauth.urls\")),\n    # optional, must be before \"wagtail.admin.urls\"\n    path(\"\", include(\"mailauth.contrib.wagtail.urls\")),\n]\n</code></pre> <p>That's it!</p> <p>Important</p> <p>Don't forget to setup you Email backend!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>To run test suite run:</p> <pre><code>uv run pytest\n</code></pre> <p>To build the documentation run:</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"contributing/#the-sample-app","title":"The sample app","text":"<p>To run a full example --- e.g. to debug frontend code -- you can run:</p> <pre><code>uv run tests/manage.py migrate\nuv run tests/manage.py createsuperuser\n# You will be asked for the email address of your new superuser\nuv run tests/manage.py runserver\n</code></pre> <p>Next you can go to https://localhost:8000/admin/ and log in with your newly created superuser.</p>"},{"location":"customizing/","title":"Customizing","text":""},{"location":"customizing/#custom-login-message-like-sms","title":"Custom login message (like SMS)","text":"<p>Django Mail Auth can be easily extended. Besides template adaptations it is possible to send different messages like SMS. To make those changes, you will need to write a custom login form.</p>"},{"location":"customizing/#custom-login-form","title":"Custom login form","text":"<p>Custom login forms need to inherit from BaseLoginForm and override the save method.</p> <p>The following example is for a login SMS. This will require a custom user model with a unique <code>phone_number</code> field:</p> <pre><code>from django import forms\nfrom django.contrib.auth import get_user_model\nfrom django.template import loader\nfrom mailauth.forms import BaseLoginForm\n\n\nclass SmsLoginForm(BaseLoginForm):\n    phone_number = forms.CharField()\n\n    template_name = 'registration/login_sms.txt\n    from_number = None\n\n    def __init__(self, *args, **kwargs):\n        self.twilio_client = TwilioRestClient(\n            settings.TWILIO_SID,\n            settings.TWILIO_AUTH_TOKEN\n        )\n        super().__init__(*args, **kwargs)\n\n    def save(self):\n        phone_number = self.cleaned_data['phone_number']\n        user = get_user_model().objects.get(\n            phone_number=phone_number\n        )\n        context = self.get_context(self.request, user)\n\n        from_number = self.from_number or getattr(\n            settings, 'DEFAULT_FROM_NUMBER'\n        )\n        sms_content = loader.render_to_string(\n            self.template_name, context\n        )\n\n        self.twilio_client.messages.create(\n            to=user.phone_number,\n            from_=from_number,\n            body=sms_content\n        )\n</code></pre> <p>To add the new login form, simply add a new login view to your URL configuration with the custom form:</p> <pre><code>from django.urls import path\nfrom mailauth.views import LoginView\n\nfrom .forms import SmsLoginForm\n\nurlpatterns = [\n    path(\"login/sms/\", LoginView.as_view(form_class=SmsLoginForm), name=\"login-sms\"),\n]\n</code></pre>"},{"location":"customizing/#api-documentation","title":"API documentation","text":"<p>               Bases: <code>Form</code></p> Source code in <code>mailauth/forms.py</code> <pre><code>class BaseLoginForm(forms.Form):\n    next = forms.CharField(widget=forms.HiddenInput, required=False)\n\n    def get_login_url(\n        self, request: django.http.request.HttpRequest, token: str, next: str = None\n    ) -&gt; str:\n        \"\"\"\n        Return user login URL including the access token.\n\n        Args:\n            request: Current request.\n            token: The user specific authentication token.\n            next: The path the user should be forwarded to after login.\n\n        Returns:\n            User login URL including the access token.\n\n        \"\"\"\n        protocol = \"https\" if request.is_secure() else \"http\"\n        current_site = get_current_site(request)\n        url = \"{protocol}://{domain}{path}\".format(\n            protocol=protocol,\n            domain=current_site.domain,\n            path=reverse(\"mailauth:login-token\", kwargs={\"token\": token}),\n        )\n        if next is not None:\n            url += f\"?next={urllib.parse.quote(next)}\"\n        return url\n\n    def get_token(self, user: django.contrib.auth.base_user.AbstractBaseUser) -&gt; str:\n        \"\"\"Return the access token.\"\"\"\n        return MailAuthBackend.get_token(user=user)\n\n    def get_mail_context(\n        self,\n        request: django.http.request.HttpRequest,\n        user: django.contrib.auth.base_user.AbstractBaseUser,\n    ) -&gt; dict[str, typing.Any]:\n        \"\"\"\n        Return the context for a message template render.\n\n        Args:\n            request: Current request.\n            user: The user requesting a login message.\n\n        Returns:\n            A context dictionary including:\n            - ``site``\n            - ``site_name``\n            - ``token``\n            - ``login_url``\n            - ``user``\n\n        \"\"\"\n        token = self.get_token(user)\n        site = get_current_site(request)\n        login_url = self.get_login_url(request, token, self.cleaned_data[\"next\"])\n        return {\n            \"site\": site,\n            \"site_name\": site.name,\n            \"token\": token,\n            \"login_url\": login_url,\n            \"user\": user,\n        }\n\n    def save(self):\n        \"\"\"\n        Send login URL to users.\n\n        Called from the login view, if the form is valid.\n\n        This method must be implemented by subclasses. This method\n        should trigger the login URL to be sent to the user.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"customizing/#mailauth.forms.BaseLoginForm.get_login_url","title":"<code>get_login_url(request, token, next=None)</code>","text":"<p>Return user login URL including the access token.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>Current request.</p> required <code>token</code> <code>str</code> <p>The user specific authentication token.</p> required <code>next</code> <code>str</code> <p>The path the user should be forwarded to after login.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>User login URL including the access token.</p> Source code in <code>mailauth/forms.py</code> <pre><code>def get_login_url(\n    self, request: django.http.request.HttpRequest, token: str, next: str = None\n) -&gt; str:\n    \"\"\"\n    Return user login URL including the access token.\n\n    Args:\n        request: Current request.\n        token: The user specific authentication token.\n        next: The path the user should be forwarded to after login.\n\n    Returns:\n        User login URL including the access token.\n\n    \"\"\"\n    protocol = \"https\" if request.is_secure() else \"http\"\n    current_site = get_current_site(request)\n    url = \"{protocol}://{domain}{path}\".format(\n        protocol=protocol,\n        domain=current_site.domain,\n        path=reverse(\"mailauth:login-token\", kwargs={\"token\": token}),\n    )\n    if next is not None:\n        url += f\"?next={urllib.parse.quote(next)}\"\n    return url\n</code></pre>"},{"location":"customizing/#mailauth.forms.BaseLoginForm.get_mail_context","title":"<code>get_mail_context(request, user)</code>","text":"<p>Return the context for a message template render.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>Current request.</p> required <code>user</code> <code>AbstractBaseUser</code> <p>The user requesting a login message.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A context dictionary including:</p> <code>dict[str, Any]</code> <ul> <li><code>site</code></li> </ul> <code>dict[str, Any]</code> <ul> <li><code>site_name</code></li> </ul> <code>dict[str, Any]</code> <ul> <li><code>token</code></li> </ul> <code>dict[str, Any]</code> <ul> <li><code>login_url</code></li> </ul> <code>dict[str, Any]</code> <ul> <li><code>user</code></li> </ul> Source code in <code>mailauth/forms.py</code> <pre><code>def get_mail_context(\n    self,\n    request: django.http.request.HttpRequest,\n    user: django.contrib.auth.base_user.AbstractBaseUser,\n) -&gt; dict[str, typing.Any]:\n    \"\"\"\n    Return the context for a message template render.\n\n    Args:\n        request: Current request.\n        user: The user requesting a login message.\n\n    Returns:\n        A context dictionary including:\n        - ``site``\n        - ``site_name``\n        - ``token``\n        - ``login_url``\n        - ``user``\n\n    \"\"\"\n    token = self.get_token(user)\n    site = get_current_site(request)\n    login_url = self.get_login_url(request, token, self.cleaned_data[\"next\"])\n    return {\n        \"site\": site,\n        \"site_name\": site.name,\n        \"token\": token,\n        \"login_url\": login_url,\n        \"user\": user,\n    }\n</code></pre>"},{"location":"customizing/#mailauth.forms.BaseLoginForm.get_token","title":"<code>get_token(user)</code>","text":"<p>Return the access token.</p> Source code in <code>mailauth/forms.py</code> <pre><code>def get_token(self, user: django.contrib.auth.base_user.AbstractBaseUser) -&gt; str:\n    \"\"\"Return the access token.\"\"\"\n    return MailAuthBackend.get_token(user=user)\n</code></pre>"},{"location":"customizing/#mailauth.forms.BaseLoginForm.save","title":"<code>save()</code>","text":"<p>Send login URL to users.</p> <p>Called from the login view, if the form is valid.</p> <p>This method must be implemented by subclasses. This method should trigger the login URL to be sent to the user.</p> Source code in <code>mailauth/forms.py</code> <pre><code>def save(self):\n    \"\"\"\n    Send login URL to users.\n\n    Called from the login view, if the form is valid.\n\n    This method must be implemented by subclasses. This method\n    should trigger the login URL to be sent to the user.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"customizing/#custom-user-model","title":"Custom User Model","text":"<p>For convenience, Django Mail Auth provides a EmailUser which is almost identical to Django's built-in User but without the password and username field. The email field serves as a username and is -- different to Django's User -- unique and case-insensitive.</p>"},{"location":"customizing/#implementing-a-custom-user-model","title":"Implementing a custom User model","text":"<pre><code>from mailauth.contrib.user.models import AbstractEmailUser\nfrom phonenumber_field.modelfields import PhoneNumberField\n\n\nclass SMSUser(AbstractEmailUser):\n    phone_number = phone = PhoneNumberField(\n        _(\"phone number\"), unique=True, db_index=True\n    )\n\n\nclass Meta(AbstractEmailUser.Meta):\n    verbose_name = _(\"user\")\n    verbose_name_plural = _(\"users\")\n    swappable = \"AUTH_USER_MODEL\"\n</code></pre> <p>Note</p> <p>Do not forget to adjust your <code>AUTH_USER_MODEL</code> to correct <code>app_label.ModelName</code>.</p>"},{"location":"customizing/#api-documentation_1","title":"API documentation","text":"<p>               Bases: <code>AbstractUser</code></p> Source code in <code>mailauth/contrib/user/models.py</code> <pre><code>class AbstractEmailUser(AbstractUser):\n    EMAIL_FIELD = \"email\"\n    USERNAME_FIELD = \"email\"\n    REQUIRED_FIELDS = []\n\n    username = None\n    password = None\n\n    email = CIEmailField(\n        _(\"email address\"), blank=True, null=True, unique=True, db_index=True\n    )\n    \"\"\"Unique and case insensitive to serve as a better username.\"\"\"\n\n    session_salt = models.CharField(\n        max_length=12,\n        editable=False,\n        default=_get_session_salt,\n    )\n    \"\"\"Salt for the session hash replacing the password in this function.\"\"\"\n\n    def has_usable_password(self):\n        return False\n\n    objects = EmailUserManager()\n\n    class Meta(AbstractUser.Meta):\n        abstract = True\n        permissions = [\n            (\"anonymize\", \"Can anonymize user\"),\n        ]\n\n    def get_session_auth_hash(self):\n        \"\"\"Return an HMAC of the :attr:`.session_salt` field.\"\"\"\n        key_salt = \"mailauth.contrib.user.models.EmailUserManager.get_session_auth_hash\"\n        if not self.session_salt:\n            raise ValueError(\"'session_salt' must be set\")\n        return salted_hmac(key_salt, self.session_salt, algorithm=\"sha256\").hexdigest()\n\n    def anonymize(self, commit=True):\n        \"\"\"\n        Anonymize the user data for privacy purposes.\n\n        This method will erase the email address, first and last name.\n        You may overwrite this method to add additional fields to anonymize::\n\n            class MyUser(AbstractEmailUser):\n                def anonymize(self, commit=True):\n                    super().anonymize(commit=False) # do not commit yet\n                    self.phone_number = None\n                    if commit:\n                        self.save()\n        \"\"\"\n        signals.anonymize.send(sender=self.__class__, instance=self)\n        self.email = None\n        self.first_name = \"\"\n        self.last_name = \"\"\n        update_fields = [\"email\", \"first_name\", \"last_name\"]\n        if commit:\n            self.save(update_fields=update_fields)\n        return update_fields\n</code></pre> <p>Unique and case insensitive to serve as a better username.</p> <p>Salt for the session hash replacing the password in this function.</p> <p>               Bases: <code>AbstractEmailUser</code></p> Source code in <code>mailauth/contrib/user/models.py</code> <pre><code>class EmailUser(AbstractEmailUser):\n    class Meta(AbstractEmailUser.Meta):\n        swappable = \"AUTH_USER_MODEL\"\n</code></pre>"},{"location":"customizing/#mailauth.contrib.user.models.AbstractEmailUser.email","title":"<code>email = CIEmailField(_('email address'), blank=True, null=True, unique=True, db_index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique and case insensitive to serve as a better username.</p>"},{"location":"customizing/#mailauth.contrib.user.models.AbstractEmailUser.session_salt","title":"<code>session_salt = models.CharField(max_length=12, editable=False, default=_get_session_salt)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Salt for the session hash replacing the password in this function.</p>"},{"location":"customizing/#mailauth.contrib.user.models.AbstractEmailUser.anonymize","title":"<code>anonymize(commit=True)</code>","text":"<p>Anonymize the user data for privacy purposes.</p> <p>This method will erase the email address, first and last name. You may overwrite this method to add additional fields to anonymize::</p> <pre><code>class MyUser(AbstractEmailUser):\n    def anonymize(self, commit=True):\n        super().anonymize(commit=False) # do not commit yet\n        self.phone_number = None\n        if commit:\n            self.save()\n</code></pre> Source code in <code>mailauth/contrib/user/models.py</code> <pre><code>def anonymize(self, commit=True):\n    \"\"\"\n    Anonymize the user data for privacy purposes.\n\n    This method will erase the email address, first and last name.\n    You may overwrite this method to add additional fields to anonymize::\n\n        class MyUser(AbstractEmailUser):\n            def anonymize(self, commit=True):\n                super().anonymize(commit=False) # do not commit yet\n                self.phone_number = None\n                if commit:\n                    self.save()\n    \"\"\"\n    signals.anonymize.send(sender=self.__class__, instance=self)\n    self.email = None\n    self.first_name = \"\"\n    self.last_name = \"\"\n    update_fields = [\"email\", \"first_name\", \"last_name\"]\n    if commit:\n        self.save(update_fields=update_fields)\n    return update_fields\n</code></pre>"},{"location":"customizing/#mailauth.contrib.user.models.AbstractEmailUser.get_session_auth_hash","title":"<code>get_session_auth_hash()</code>","text":"<p>Return an HMAC of the :attr:<code>.session_salt</code> field.</p> Source code in <code>mailauth/contrib/user/models.py</code> <pre><code>def get_session_auth_hash(self):\n    \"\"\"Return an HMAC of the :attr:`.session_salt` field.\"\"\"\n    key_salt = \"mailauth.contrib.user.models.EmailUserManager.get_session_auth_hash\"\n    if not self.session_salt:\n        raise ValueError(\"'session_salt' must be set\")\n    return salted_hmac(key_salt, self.session_salt, algorithm=\"sha256\").hexdigest()\n</code></pre>"},{"location":"privacy/","title":"Privacy","text":""},{"location":"privacy/#anonymization","title":"Anonymization","text":"<p>User privacy is important, not only to meet local regulations, but also to protect your users and allow them to exercise their rights. However, it's not always practical to delete users, especially if they have dependent objects, that are relevant for statistical analysis.</p> <p>Anonymization is a process of removing the user's personal data whilst keeping related data intact. This is done by using the <code>anomymize</code> method.</p> <p>Anonymize the user data for privacy purposes.</p> <p>This method will erase the email address, first and last name. You may overwrite this method to add additional fields to anonymize::</p> <pre><code>class MyUser(AbstractEmailUser):\n    def anonymize(self, commit=True):\n        super().anonymize(commit=False) # do not commit yet\n        self.phone_number = None\n        if commit:\n            self.save()\n</code></pre> Source code in <code>mailauth/contrib/user/models.py</code> <pre><code>def anonymize(self, commit=True):\n    \"\"\"\n    Anonymize the user data for privacy purposes.\n\n    This method will erase the email address, first and last name.\n    You may overwrite this method to add additional fields to anonymize::\n\n        class MyUser(AbstractEmailUser):\n            def anonymize(self, commit=True):\n                super().anonymize(commit=False) # do not commit yet\n                self.phone_number = None\n                if commit:\n                    self.save()\n    \"\"\"\n    signals.anonymize.send(sender=self.__class__, instance=self)\n    self.email = None\n    self.first_name = \"\"\n    self.last_name = \"\"\n    update_fields = [\"email\", \"first_name\", \"last_name\"]\n    if commit:\n        self.save(update_fields=update_fields)\n    return update_fields\n</code></pre> <p>This method may be overwritten to provide anonymization for you custom user model.</p> <p>Related objects may also listen to the anonymize signal.</p> <p>Signal that is emitted when a user and all their data should be anonymized.</p> <p>The signal is emitted before the private date is delete on the instance, thus the receiver can still access the data. The receiver should usually not alter the instance, but only later related data. We recommend overriding the anonymize method to modify the instance.</p> <p>Usage::</p> <pre><code>from django.dispatch import receiver\nfrom mailauth.contrib.user.models import EmailUser\nfrom mailauth.contrib.user.signals import anonymize\n\n\n@receiver(anonymize, sender=EmailUser)\ndef anonymize_user(sender, instance, **kwargs):\n    # Do something with related user data\n    instance.related_model.delete()\n</code></pre> <p>All those methods can be conveniently triggered via the <code>anonymize</code> admin action.</p> <p>Mixin for admin classes that provides a <code>anonymize</code> action.</p> <p>This mixin calls the <code>anonymize</code> method of all user model instances.</p> Source code in <code>mailauth/contrib/user/admin.py</code> <pre><code>class AnonymizableAdminMixin:\n    \"\"\"\n    Mixin for admin classes that provides a `anonymize` action.\n\n    This mixin calls the `anonymize` method of all user model instances.\n    \"\"\"\n\n    actions = [\"anonymize\"]\n\n    @admin.action(\n        permissions=[\"anonymize\"],\n        description=_(\"Anonymize selected %(verbose_name_plural)s\"),\n    )\n    def anonymize(self, request, queryset):\n        count = queryset.count()\n        for user in queryset.iterator():\n            user.anonymize()\n\n        self.message_user(\n            request,\n            ngettext(\n                \"%(count)s %(obj_name)s has successfully been anonymized.\",\n                \"%(count)s %(obj_name)s have successfully been anonymized.\",\n                count,\n            )\n            % {\n                \"count\": count,\n                \"obj_name\": (\n                    self.model._meta.verbose_name_plural\n                    if count &gt; 1\n                    else self.model._meta.verbose_name\n                ),\n            },\n            fail_silently=True,\n        )\n\n    def has_anonymize_permission(self, request, obj=None):\n        return request.user.has_perm(f\"{self.opts.app_label}.anonymize\", obj=obj)\n</code></pre>"},{"location":"privacy/#liability-waiver","title":"Liability Waiver","text":"<p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"settings/","title":"Settings","text":""},{"location":"settings/#mail-auth-settings","title":"Mail Auth settings","text":"<p><code>LOGIN_URL_TIMEOUT</code> Default: <code>900</code></p> <p>Defines how long a login code is valid in seconds.</p> <p><code>LOGIN_REQUESTED_URL</code> Default: <code>accounts/login/success</code></p> <p>Defines the URL the user will be redirected to, after requesting an authentication message.</p> <p><code>LOGIN_TOKEN_SINGLE_USE</code> Default: <code>True</code></p> <p>Defines if a token can be used more than once. If <code>True</code>, the same token can only be used once and will be invalid the next try. If <code>False</code>, the same token can be used multiple times and remains valid until expired.</p>"},{"location":"settings/#django-related-settings","title":"Django related settings","text":"<p><code>DEFAULT_FROM_EMAIL</code> Default: <code>'root@example.com'</code></p> <p>The sender email address for authentication emails send by Django Mail Auth.</p> <p><code>SECRET_KEY</code></p> <p>Warning</p> <p>Keep it secret, keep it safe!</p> <p>This key is the foundation of all of Django security measures and for this package.</p>"},{"location":"templates/","title":"Templates","text":"<p>There are a couple relevant templates, that can be overridden to your needs.</p>"},{"location":"templates/#mail-auth-templates","title":"Mail Auth templates","text":""},{"location":"templates/#login-templates","title":"Login templates","text":"<p><code>registration/login_requested.html</code></p> <p>This template will be displayed after a user successfully requested a login URL. This template is not proved by the package and needs to be created.</p>"},{"location":"templates/#email-templates","title":"Email templates","text":"<p><code>registration/login_subject.txt</code></p> <p>This template defines the subject line of the email that will be sent to the user.</p> <p>This template is provided by the package and can be overridden.</p> <p><code>registration/login_email.txt</code></p> <p>This is the plain text template for the email containing the authentication URL that will be sent to the user.</p> <p>This template is provided by the package and can be overridden.</p> <p><code>registration/login_email.html</code></p> <p>This is the HTML template for the email containing the authentication URL that will be sent to the user.</p> <p>This template is optional. If not provided, only plain text emails will be sent.</p>"},{"location":"templates/#django-related-templates","title":"Django related templates","text":"<p>Mail Auth uses Django's default templates for the login views.</p>"},{"location":"templates/#login-templates_1","title":"Login templates","text":"<p><code>registration/login.html</code></p> <p>This template displays login form, where a user can request a login URL. This template is not proved Django or by the package and needs to be created.</p> <p><code>registration/logged_out.html</code></p> <p>This template will be displayed after a successful logout. This template is not proved Django or by the package and needs to be created.</p>"}]}